<?php
<<<<<<< Updated upstream
require_once(dirname(__FILE__) . '/../../TestConfig.php');
=======
use libraries\lfdictionary\environment\ProjectStates;

use libraries\lfdictionary\environment\ProjectState;

use models\ProjectModel;

require_once(dirname(__FILE__) . '/../../testconfig.php');
>>>>>>> Stashed changes
require_once(SIMPLETEST_PATH . 'autorun.php');
require_once(LF_BASE_PATH . "Loader.php");

use \libraries\lfdictionary\common\HgWrapper;
use libraries\lfdictionary\environment\LexProject;
class LexProjectTestEnvironment {
	
	/**
	 * @var string
	 */
	public $projectWorkPath;
	
	/**
	 * 
	 * @var string
	 */
	public $projectCode;
	
	/**
	 * @var HgWrapper
	 */
	private $_hg;
	
	/**
	 * 
	 * @var LexProject
	 */
	public $lexProject;
	
	const PROJECT_NAME = 'LexProject_Test';
	
	function __construct($projectName = self::PROJECT_NAME, $projectWorkPath = null, $doInit = true) {
		$this->projectCode = ProjectModel::makeProjectCode('qaa', $projectName, "dictionary");
		if ($projectWorkPath == null) {
			$this->projectWorkPath = self::normalizePath(sys_get_temp_dir());
			self::recursiveDelete($this->getProjectPath());
		}
		if ($doInit) {
			if (!file_exists($this->getProjectPath())) {
				mkdir($this->getProjectPath());
			}
			$this->_hg = new \libraries\lfdictionary\common\HgWrapper($this->getProjectPath());
			$this->_hg->init();
		}
		$model= new ProjectModel();
		$model->projectName = $projectName;
		$model->projectCode = $this->projectCode;
		$this->lexProject = new LexProject($model, '/tmp/');
	}
	
	function __destruct() {
 		self::recursiveDelete($this->getProjectPath());
// 		echo "destruct";
	}

	public function getProjectPath() {
		return self::normalizePath($this->projectWorkPath . $this->projectCode);
	}
	
	static private function recursiveDelete($str) {
		if(is_file($str)) {
			return @unlink($str);
		} elseif(is_dir($str)) {
			$str = self::normalizePath($str);
			$objects = scandir($str);
			foreach ($objects as $object) {
				if ($object === "." || $object === "..") {
					continue;
				}
				self::recursiveDelete($str . $object);
			}
			reset($objects);
			@rmdir($str);
		}
	}
	
	static private function normalizePath($path) {
		$path = rtrim($path, DIRECTORY_SEPARATOR) . DIRECTORY_SEPARATOR;
		return $path;
	}
	
	public function addFile($fileName, $contents) {
		$filePath = $this->getProjectPath() . $fileName;
		file_put_contents($filePath, $contents);
		$this->_hg->addFile($filePath);
		$this->_hg->commit("File added");
	}
	
}

class TestOfLexProject extends UnitTestCase {

	function testConstructor_NormalizedProjectPath() {
		$model = new ProjectModel();
		$model->projectname = "SomeProject";
		$model->projectCode = ProjectModel::makeProjectCode("qaa", "SomeProject", "dictionary");
		$project = new LexProject($model, '/tmp');
		$this->assertEqual('/tmp/qaa-someproject-dictionary/', $project->projectPath);
	}
	
	function testConstructor_NonExistentProject_StateReady() {
		$model = new ProjectModel();
		$model->projectname = "SomeProject";
		$model->projectCode = ProjectModel::makeProjectCode("qaa", "SomeProject", "dictionary");
		$project = new LexProject($model, '/tmp');
		$this->assertEqual($project->projectState->getState(), ProjectStates::Ready);
	}
	
	function testConstructor_ExistingProject_ProjectStateReadOk() {
		$model = new ProjectModel();
		$model->projectname = "SomeProject";
		$model->projectCode = ProjectModel::makeProjectCode("qaa", "SomeProject", "dictionary");
		$project = new LexProject($model, '/tmp');
		$project->createNewProject();
		$project->projectState->setState(ProjectStates::Locked);
		$project2 = new LexProject($model, '/tmp');
		$this->assertEqual($project2->projectState->getState(), ProjectStates::Locked);
	}
	
	function testCreateNewProject_ExistingProject_Throws() {
		$e = new LexProjectTestEnvironment();
		$e->lexProject->createNewProject();
		$this->expectException('Exception');
		$e->lexProject->createNewProject();
	}
	
	function testCreateNewProject_NewProject_Created() {
		$e = new LexProjectTestEnvironment();
		$e->lexProject->createNewProject();
		$this->assertFileExists($e->lexProject->projectPath . $e->projectCode . ".lift");
	}
	
	function tetGetLiftFilePath_NoLiftFile_NewDefaultCreated() {
		$e = new LexProjectTestEnvironment();
		$expected = $e->projectName . '.lift';
		$e->addFile($expected, '<lift />');
		$project = new LexProject($e->projectCode, $e->projectWorkPath);
		$result = $project->getLiftFilePath();
		$this->assertEqual($e->getProjectPath() . $expected, $result);
	}
	
	function testGetLiftFilePath_LiftFileWithProjectName_ReturnsPath() {}
	
	function testGetLiftFilePath_TwoLiftfiles_ReturnsProjectLiftFile() {}
	
	function testGetLiftFilePath_LiftFileWithRandomName_ReturnsPath() {}
	
	function testGetCurrentHash_SomeRepo_ReturnsHash() {
		$e = new LexProjectTestEnvironment();
		$e->addFile("File1.txt", "Contents");
		
		$project = new LexProject($e->projectName, $e->projectWorkPath);
		$result = $project->getCurrentHash();
		$this->assertEqual(12, strlen($result));
	}
/*	
	function testGetLiftFilePath_NoLiftFile_Throws() {
		$e = new LexProjectTestEnvironment();
		$project = new LexProject($e->projectName, $e->projectWorkPath);
		$this->expectException('Exception');
		$result = $project->getLiftFilePath();
	}
	
	function testGetLiftFilePath_LiftFile_ReturnsFilePath() {
		$expected = 'Test.lift';
		$e = new LexProjectTestEnvironment();
		$e->addFile($expected, '<lift />');
		$project = new LexProject($e->projectName, $e->projectWorkPath);
		$result = $project->getLiftFilePath();
		$this->assertEqual($e->getProjectPath() . $expected, $result);
	}
	*/
	
	private function assertFileExists($filePath) {
		$this->assertTrue(file_exists($filePath), sprintf("Expected file not found '%s'", $filePath));
	}
	
}

?>