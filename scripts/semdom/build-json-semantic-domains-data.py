#!/usr/bin/env python


"""Parses semantic domain data from Ddp4.xml file (and related Ddp4Questions-*.xml files),
and outputs JSON data in the following format:

var semanticDomains_en = {
    '1.1 Sky': {
        'key': '1.1',
        'guid': '999581c4-1611-4acb-ae1b-5e6c1dfe6f0c',
        'name': 'Sky',
        'abbreviation': '1.1',
        'description': 'Use this domain for words related to the sky.',
        'searchKeys': 'sky, firmament, canopy, vault',
    },
    # ...
};

var semanticDomainQuestions_en = {
    '1.1 Sky': [
        'What words refer to the air around the earth? (air, atmosphere, airspace, stratosphere, ozone layer)',
        'What words are used to refer to the place or area beyond the sky? (heaven, space, outer space, ether, void, solar system)',
        # ...
    ],
    # ...
}

The GUIDs found in the output data will be the GUIDs that FieldWorks uses for its semantic domains, as found in
src/resources/languageforge/semdomtrans/SemDom_en.xml
"""

import os, sys
import re
from pprint import pprint, pformat
import codecs
import collections
import json
import lxml
from lxml import etree
import glob

# Constants - mostly hardcoded filenames
DDP_FNAME = "Ddp4.xml"
SEMDOM_EN_FNAME = "SemDom_en.xml"
SEMDOM_EN_PATH = "src/resources/languageforge/semdomtrans/{}".format(SEMDOM_EN_FNAME)
QUESTIONS_FNAME_BASE = "Ddp4Questions-{}.xml"
DEFAULT_LANG = 'en' # If any language is lacking certain domains, substitute English for missing domains
ALL_LANGUAGES = ['en', 'es', 'fr', 'hi', 'id', 'km', 'ne', 'ru', 'th', 'ur', 'zh-CN']
LANGUAGES_TO_PROCESS = ['en']

OUTPUT_DDP_FNAME_BASE = "semanticDomains_{}.js"
OUTPUT_QUESTIONS_FNAME_BASE = "semanticDomainQuestions_{}.js"

# OUTPUT_PREFIX is the text to write *before* the JSON output
OUTPUT_PREFIX_DOMAINS = """\
'use strict';

// THIS FILE IS AUTOMATICALLY GENERATED.
// Do not make changes to this file; they will be overwritten.

// input systems languages data
var semanticDomains_{} = """

OUTPUT_PREFIX_QUESTIONS = OUTPUT_PREFIX_DOMAINS.replace('Domains', 'DomainQuestions')

# OUTPUT_SUFFIX is the text to write *after* the JSON output
OUTPUT_SUFFIX = ";\n"

def find_gitroot(startpath=None):
    if startpath is None:
        startpath = os.getcwd()
    curpath = os.path.abspath(startpath)
    while not os.path.exists(os.path.join(curpath, ".git")):
        parent = os.path.abspath(os.path.join(curpath, ".."))
        if parent == curpath:
            # Hit filesystem root without finding a Git repo
            return None
        curpath = parent
    return curpath

def gitrooted_filename(fname, startpath=None):
    return os.path.join(find_gitroot(startpath), fname)

def parse_file(fname):
    with codecs.open(fname, 'rU', 'utf-8-sig') as f:
        return etree.parse(f)

def build_guid_lookups(semdom_tree, lang="en"):
    result = {}
    for elem in semdom_tree.iter('CmSemanticDomain'):
        if not elem.attrib.has_key("guid"):
            continue
        guid = elem.attrib["guid"].strip().lower()  # RFC 4122 section 3 says output GUIDs should be LOWERCASE
        abbr = elem.find("./Abbreviation/AUni[@ws='{}']".format(lang))
        if abbr is None:
            continue
        result[abbr.text.strip()] = guid
    return result

def build_ddp_data(tree, guids_by_abbr, lang):
    result = collections.OrderedDict()
    for option in tree.iter('option'):
        record = collections.OrderedDict()
        key = option.find("./key").text
        # English abbreviations are used as unchanging, unique keys in LF optionlist
        en_abbr = option.find("./abbreviation/form[@ws='{0}']".format(DEFAULT_LANG))
        en_abbr_text = en_abbr.text.strip()
        record['key'] = en_abbr_text
        if en_abbr_text in guids_by_abbr:
            record['guid'] = guids_by_abbr[en_abbr_text]
        for elemName in ["name", "abbreviation", "description"]:
            elem = option.find("./{0}/form[@ws='{1}']".format(elemName, lang))
            if elem is None:
                elem = option.find("./{0}/form[@ws='{1}']".format(elemName, DEFAULT_LANG))
            record[elemName] = elem.text.strip()
        # searchKeys needs to be a list, not a string: each language has multiple searchKey entries
        record['searchKeys'] = [elem.text.strip() for elem in option.findall("./searchKeys/form[@ws='{}']".format(lang))]
        result[key] = record
    return result

def build_question_data(tree, lang):
    result = collections.OrderedDict()
    for domain in tree.iter('semantic-domain'):
        key = domain.get('id')
        questions = [elem.text.strip().replace('\r', '\n') for elem in domain.findall("./question") if elem.text is not None]
        result[key] = questions
    return result

def write_json(data, lang, out_fname, prefix, suffix):
    with codecs.open(out_fname, 'wU', 'utf-8') as f:
        f.write(prefix)
        json.dump(data, f, ensure_ascii=False, indent=2, separators=(',', ' : '))
        f.write(suffix)

def main():
    sys.stderr.write("Processing languages {}...\n".format(repr(ALL_LANGUAGES)))
    ddp_tree = parse_file(DDP_FNAME)
    semdom_tree = parse_file(gitrooted_filename(SEMDOM_EN_PATH))
    guids_by_abbr = build_guid_lookups(semdom_tree, DEFAULT_LANG)
    for lang in ALL_LANGUAGES:  # Replace with LANGUAGES_TO_PROCESS if desired
        underscore_lang = lang.replace('-', '_')  # So zh-CN doesn't produce invalid Javascript

        data = build_ddp_data(ddp_tree, guids_by_abbr, lang)
        fname = OUTPUT_DDP_FNAME_BASE.format(lang)
        write_json(data, lang, fname, OUTPUT_PREFIX_DOMAINS.format(underscore_lang), OUTPUT_SUFFIX)

        if not os.path.exists(QUESTIONS_FNAME_BASE.format(lang)):
            print "No questions file found for language tag \"{}\"; this language will have only example words but no questions.".format(lang)
            continue
        questions_tree = parse_file(QUESTIONS_FNAME_BASE.format(lang))
        data = build_question_data(questions_tree, lang)
        fname = OUTPUT_QUESTIONS_FNAME_BASE.format(lang)
        write_json(data, lang, fname, OUTPUT_PREFIX_QUESTIONS.format(underscore_lang), OUTPUT_SUFFIX)

# To convert:
# root.findall('.//option')
# for each option:
#   extract ./key, ./name, ./abbreviation, ./description, ./searchKeys
#   find ws="en" (or current language)
#   put data in result dict

if __name__ == '__main__':
    main()
