'use strict';

angular.module('translate.editor', ['ui.router', 'ui.bootstrap', 'bellows.services', 'ngQuill',
  'translate.suggest'])
  .config(['$stateProvider', function ($stateProvider) {

    // State machine from ui.router
    $stateProvider
      .state('editor', {
        url: '/editor',
        templateUrl: '/angular-app/languageforge/translate/views/editor.html',
        controller: 'EditorCtrl'
      })
    ;
  }])
  .controller('EditorCtrl', ['$scope', 'translateAssistant', 'wordParser',
  function ($scope, assistant, wordParser) {
    var realTime = require('../../../../node/client').realTime;
    var currentDocIds = [];
    var editors = {};
    var source = {
      docType: 'source',
      label: 'Source',
      languageTag: 'es'
    };
    var target = {
      docType: 'target',
      label: 'Target',
      languageTag: 'en',
      confidenceThreshold: 0.2
    };

    assistant.initialise(source.languageTag, target.languageTag);

    $scope.left = source;
    $scope.right = target;
    $scope.modulesConfig = {
      toolbar: [
        ['bold', 'italic', 'underline', 'strike'],      // toggled buttons
        [{ script: 'sub' }, { script: 'super' }],       // superscript/subscript
        [{ indent: '-1' }, { indent: '+1' }],           // outdent/indent
        [{ align: [] }],

        [{ size: ['small', false, 'large', 'huge'] }],  // custom dropdown
        [{ font: [] }],
        [{ color: [] }, { background: [] }],            // dropdown with defaults from theme
        [{ direction: 'rtl' }],                         // text direction
        ['clean']                                       // remove formatting button
      ],

      suggestions: {
        container: '.ql-suggestions'
      }
    };

    $scope.getLabel = function getLabel(label, languageTag) {
      return label + ((languageTag) ? ' (' + languageTag + ')' : '');
    };

    $scope.contentChanged =
      function contentChanged(editor, html, text, docType, side) {
        if (currentDocIds[docType] != docId(docType)) {
          realTime.disconnectRichTextDoc(currentDocIds[docType]);
          delete currentDocIds[docType];
          $scope.editorCreated(editor, docType, side);
        } else {
          getSuggestions(editor, docType);
        }
      };

    $scope.editorCreated = function editorCreated(editor, docType, side) {
      editors[side] = editor;
      currentDocIds[docType] = docId(docType);
      realTime.createAndSubscribeRichTextDoc($scope.project.slug, docId(docType), editor);
      getSuggestions(editor, docType);
      editor.on('selection-change', function () {
        if (docType == 'target') {
          $scope.contentChanged(editor, null, null, docType, side);
        } else {
          editor.theme.suggestTooltip.hide();
        }
      });
    };

    $scope.swapEditors = function swapEditors() {
      realTime.disconnectRichTextDoc(currentDocIds[$scope.left.docType]);
      realTime.disconnectRichTextDoc(currentDocIds[$scope.right.docType]);
      currentDocIds = [];

      var newLeft = $scope.right;
      var newRight = $scope.left;
      delete $scope.right;
      delete $scope.left;
      $scope.right = newRight;
      $scope.left = newLeft;
      $scope.editorCreated(editors.left, newLeft.docType, 'left');
      $scope.editorCreated(editors.right, newRight.docType, 'right');
    };

    $scope.insertSuggestion = function insertSuggestion(side, text) {
      var editor = editors[side];
      var range = editor.selection.lastRange;
      var currentText = removeTrailingCarriageReturn(editor.getText());
      var words = wordParser.wordBreak(currentText);
      if (hasNoSelectionAtCursor(range)) {
        var index = range.index;
        var wordStartIndex = wordParser.startIndexOfWordAt(index, words);
        var wordLength = wordParser.lengthOfWordAt(index, words);
        setTimeout(function () {
          if (index < (currentText.length) ||
            (index == (currentText.length) && !wordParser.isWordComplete(currentText[index - 1]))
          ) {
            editor.deleteText(wordStartIndex, wordLength + 1, 'user');
            index = wordStartIndex;
          }

          editor.insertText(index, text + wordParser.charSpace(), 'user');
        }, 1);
      }
    };

    function docId(docKey) {
      return $scope.project.id + ':' + docKey;
    }

    /**
     * @param {string} text
     * @returns {string}
     */
    function removeTrailingCarriageReturn(text) {
      return (text.endsWith('\n')) ? text.substr(0, text.length - 1) : text;
    }

    function getSuggestions(editor, docType) {
      if (docType == 'target' && source.data && target.data) {
        var segmentIndex = getCurrentSegmentIndex(target.data, editor.getSelection());
        assistant.setPrefix(
          wordParser.wordBreak(currentSegment(source.data, segmentIndex)),
          target.confidenceThreshold,
          wordParser.wordBreak(currentSegment(target.data, segmentIndex)),
          wordParser.isWordComplete(currentSegment(target.data, segmentIndex)),
          function (suggestions) {
            $scope.$apply(function () {
              target.suggestions = suggestions;
              setTimeout(function () {
                showAndPositionTooltip(editor.theme.suggestTooltip, editor.getSelection(), editor);
              }, 1);
            });
          }
        );
      } else {
        editor.theme.suggestTooltip.hide();
      }
    }

    function showAndPositionTooltip(tooltip, range, editor) {
      if (hasNoSelectionAtCursor(range) && hasSuggestion()) {
        tooltip.show();
        tooltip.position(editor.getBounds(range));
      } else {
        tooltip.hide();
      }
    }

    function hasNoSelectionAtCursor(range) {
      return range && range.length == 0;
    }

    function hasSuggestion() {
      return target.suggestions && target.suggestions.length > 0;
    }

    /**
     * @param {string} data
     * @param {number} index
     * @returns {string}
     */
    function currentSegment(data, index) {
      if (index > getLastSegmentIndex(data)) {
        index = getLastSegmentIndex(data);
      }

      return getSegments(data)[index];
    }

    /**
     * @param {string} data
     * @returns {number}
     */
    function getLastSegmentIndex(data) {
      return getSegments(data).length - 1;
    }

    /**
     * @param {string} data
     * @param {Range} range
     * @returns {number}
     */
    function getCurrentSegmentIndex(data, range) {
      if (hasNoSelectionAtCursor(range)) {
        var segmentIndex = 0;
        var nextSegmentIndex = 0;
        angular.forEach(getSegments(data), function (segment) {
          nextSegmentIndex += segment.length + '\n'.length;
          if (range.index < nextSegmentIndex) return;

          segmentIndex++;
        });

        return segmentIndex;
      } else {
        return getLastSegmentIndex(data);
      }
    }

    /**
     * Remove first opening <p> and last closing </p>, split on paragraphs to segment
     * @param {string} data
     * @returns {Array|*}
     */
    function getSegments(data) {
      data = data.replace(/^(<p>)/, '');
      data = data.replace(/(<\/p>)$/, '');
      return data.split('</p><p>');
    }

    // -----------------------------------------------------------------
    // Add a suggest tooltip to Quill
    // -----------------------------------------------------------------

    var Tooltip = Quill.import('ui/tooltip');
    function SuggestTooltip(quill, boundsContainer) {
      //noinspection JSUnusedGlobalSymbols
      this.boundsContainer = boundsContainer || document.body;
      this.quill = quill;
      this.root = quill.addContainer('ql-suggest-tooltip');
      this.root.innerHTML = this.constructor.TEMPLATE;
      var offset = parseInt(window.getComputedStyle(this.root).marginTop);
      this.quill.root.addEventListener('scroll', function () {
        this.root.style.marginTop = (-1 * this.quill.root.scrollTop) + offset + 'px';
      }.bind(this));
      this.hide();
    }

    SuggestTooltip.TEMPLATE = '<span class="ql-suggest-tooltip-arrow"></span>';
    SuggestTooltip.prototype = Object.create(Tooltip.prototype);
    SuggestTooltip.prototype.constructor = SuggestTooltip;
    SuggestTooltip.prototype.position = function (reference) {
      var shift = getSuper(SuggestTooltip, 'position', this).call(this, reference);
      var top = reference.bottom + this.quill.root.scrollTop + 10;
      this.root.style.top = top + 'px';
      var arrow = this.root.querySelector('.ql-suggest-tooltip-arrow');
      arrow.style.marginLeft = '';
      if (shift === 0) return shift;
      arrow.style.marginLeft = (-1 * shift - arrow.offsetWidth / 2) + 'px';
    };

    var BubbleTheme = Quill.import('themes/bubble');
    function SuggestBubbleTheme(quill, options) {
      BubbleTheme.call(this, quill, options);
      this.suggestTooltip = new SuggestTooltip(this.quill, this.options.bounds);
    }

    SuggestBubbleTheme.prototype = Object.create(BubbleTheme.prototype);
    SuggestBubbleTheme.prototype.constructor = SuggestBubbleTheme;
    SuggestBubbleTheme.prototype._super = BubbleTheme;

    var Module = Quill.import('core/module');
    function Suggestions(quill, options) {
      Module.call(this, quill, options);

      // initially container is sibling of <ng-quill-editor>
      this.container = quill.container.parentNode.parentNode.querySelector(options.container);
      quill.theme.suggestTooltip.root.appendChild(this.container);
    }

    Suggestions.prototype = Object.create(Module.prototype);
    Suggestions.prototype.constructor = Suggestions;

    Quill.register('ui/suggest-tooltip', SuggestTooltip);
    Quill.register('themes/bubble-suggest', SuggestBubbleTheme);
    Quill.register('modules/suggestions', Suggestions);

    /**
     * Gets the parent (super class) function to call
     * from quill.js _get
     * @param objectClass
     * @param property
     * @param receiver
     * @returns {*}
     */
    function getSuper(objectClass, property, receiver) {
      var object = objectClass.prototype.__proto__ || Object.getPrototypeOf(objectClass.prototype);
      return get(object, property, receiver);
    }

    function get(object, property, receiver) {
      if (object === null) object = Function.prototype;
      var desc = Object.getOwnPropertyDescriptor(object, property);
      if (desc === undefined) {
        var parent = Object.getPrototypeOf(object);
        if (parent === null) return undefined;

        return get(parent, property, receiver);
      } else if ('value' in desc) {
        return desc.value;
      } else {
        var getter = desc.get;
        if (getter === undefined) return undefined;

        return getter.call(receiver);
      }
    }

  }])

  ;
